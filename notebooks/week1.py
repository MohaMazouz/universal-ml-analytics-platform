# -*- coding: utf-8 -*-
"""Week1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IdvpcJgf8aOP29x3Q30sjOToDp9QUw3t

# **Tâche 1.1 : Audit des Données Existantes**

data_processing.py
"""

import pandas as pd
import numpy as np
from datetime import datetime
from IPython.display import display

def explore_data_structure(file_path):
    """Exploration complète de la structure des données"""
    print(" AUDIT DES DONNÉES")
    print("="*50)

    # Chargement
    import os
    excel_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '../data/updated_BD V2.xlsx'))
    print(f"Chemin absolu du fichier Excel : {excel_path}")
    df = pd.read_excel(excel_path)

    print(f" INFORMATIONS GÉNÉRALES:")
    print(f"• Taille du dataset: {df.shape[0]} lignes, {df.shape[1]} colonnes")
    # Using format() instead of f-string for this line to avoid syntax error
    print("• Période couverte: {} à {}".format(df['Date d\'Emission'].min(), df['Date d\'Emission'].max()))
    print(f"• Nombre de clients uniques: {df['Code Client'].nunique()}")

    print("\nAvailable columns:", df.columns.tolist()) # Print available columns

    print(f"\n MONTANTS:")
    # Check if 'T.T.C' column exists before accessing it
    if 'T.T.C' in df.columns:
        print(f"• Total TTC: {df['T.T.C'].sum():,.2f} €")
        print(f"• Montant moyen par facture: {df['T.T.C'].mean():,.2f} €")
        print(f"• Plus grosse facture: {df['T.T.C'].max():,.2f} €")
    else:
        print("• 'T.T.C' column not found in the DataFrame.")


    print(f"\n QUALITÉ DES DONNÉES:")
    missing_data = df.isnull().sum()
    print("• Valeurs manquantes par colonne:")
    for col, missing in missing_data.items():
        if missing > 0:
            print(f"  - {col}: {missing} ({missing/len(df)*100:.1f}%)")

    print(f"\n TOP 5 CLIENTS (par CA):")
    # Check if 'T.T.C' and 'Client' columns exist before accessing them
    if 'T.T.C' in df.columns and 'Client' in df.columns:
        top_clients = df.groupby('Client')['T.T.C'].sum().sort_values(ascending=False).head()
        for client, ca in top_clients.items():
            print(f"  - {client}: {ca:,.2f} €")
    else:
        print("• 'T.T.C' or 'Client' column not found for Top 5 Clients calculation.")


    print(f"\n STATUT ENCAISSEMENT:")
    # Check if 'Encaissement' column exists before accessing it
    if 'Encaissement' in df.columns:
        encaissement_status = df['Encaissement'].value_counts()
        print(f"• Factures payées (OUI): {encaissement_status.get('OUI', 0)}")
        print(f"• Factures impayées: {len(df) - encaissement_status.get('OUI', 0)}")
    else:
         print("• 'Encaissement' column not found for Encaissement Status.")


    return df

# Utilisation
df = explore_data_structure("../data/updated_BD V2.xlsx")

"""# **Tâche 1.2 : Nettoyage Initial**

fonction de nettoyage
"""

def clean_financial_data(df):
    """Nettoie les données financières selon le format français"""
    print("NETTOYAGE DES DONNÉES")
    print("="*30)

    df_clean = df.copy()
    initial_rows = len(df_clean)

    # 1. Conversion des montants (format français avec virgules)
    # Correcting column names to include spaces
    numeric_cols = [' H.T ', ' T.V.A ', ' T.R ', ' T.T.C ', ' Caution ', ' Montant ']

    for col in numeric_cols:
        # Adding a check to see if the column exists before processing
        if col in df_clean.columns:
            print(f"Nettoyage colonne {col}...")
            # Remplacer virgules par points et supprimer espaces
            df_clean[col] = df_clean[col].astype(str).str.replace(',', '.').str.replace(' ', '')
            df_clean[col] = pd.to_numeric(df_clean[col], errors='coerce')
        else:
            print(f"Column {col} not found. Skipping.")


    # 2. Conversion des dates
    # Correcting column names to include spaces if necessary, based on previous output
    date_cols = ["Date d'Emission", 'échéance', 'Date Encaissement'] # Assuming 'échéance' is the correct column name based on output
    for col in date_cols:
        if col in df_clean.columns:
            print(f"Conversion date {col}...")
            df_clean[col] = pd.to_datetime(df_clean[col], errors='coerce')
        else:
             print(f"Column {col} not found. Skipping.")


    # 3. Suppression des lignes problématiques
    # Montants négatifs ou nuls - Using the corrected column name
    if ' T.T.C ' in df_clean.columns:
        df_clean = df_clean[df_clean[' T.T.C '] > 0]
    else:
        print("' T.T.C ' column not found. Skipping filtering by positive TTC.")


    # Dates d'émission après échéance (impossible) - Using corrected column names
    if "Date d'Emission" in df_clean.columns and 'échéance' in df_clean.columns:
         df_clean = df_clean[df_clean['Date d\'Emission'] <= df_clean['échéance']]
    else:
        print("'Date d\'Emission' or 'échéance' column not found. Skipping filtering by date order.")


    print(f" Nettoyage terminé:")
    print(f"• Lignes supprimées: {initial_rows - len(df_clean)}")
    print(f"• Lignes conservées: {len(df_clean)}")

    return df_clean

# Test du nettoyage
df_clean = clean_financial_data(df)

"""# Tâche 2.1 : Règles d'Échéance

logique 30/60 jours
"""

def apply_payment_delay_rules(df):
    """Applique les règles métier 30/60 jours"""
    print(" APPLICATION DES RÈGLES MÉTIER")
    print("="*40)

    df_rules = df.copy()
    today = pd.Timestamp.now()

    def calculate_delay_status(row):
        """Calcule le statut selon vos règles: <30j, 30-60j, >60j"""
        # Correcting column name to lowercase 'échéance'
        echeance = row['échéance']

        if pd.isna(echeance):
            return 'Échéance manquante', 0, 'Indéterminé'

        # Si facture payée, calculer retard au moment du paiement
        # Correcting column name to include spaces if necessary, based on previous output
        if row['Encaissement'] == 'OUI' and pd.notna(row['Date Encaissement']):
            days_late = (row['Date Encaissement'] - echeance).days
            reference_date = row['Date Encaissement']
        else:
            # Facture impayée, calculer retard par rapport à aujourd'hui
            days_late = (today - echeance).days
            reference_date = today


        # Application de VOS règles métier spécifiques
        if days_late < 0:
            return 'Payée avant échéance', days_late, 'Aucun retard' # Correctly categorize negative days_late
        elif days_late <= 30:
            return 'Dans les délais', days_late, 'Pas de retard'  # 0-30 jrs: pas de retard
        elif days_late <= 60:
            return 'En retard', days_late, 'Retard'  # 30-60 jrs: retard
        else:
            return 'Retard exagéré', days_late, 'Retard exagéré'  # >60 jours: retard exagéré


    # Application des calculs
    df_rules[['Statut_Détaillé', 'Jours_Retard', 'Catégorie_Règle']] = df_rules.apply(
        calculate_delay_status, axis=1, result_type='expand'
    )

    # Indicateurs binaires pour analyses
    # Correcting the logic to set Est_En_Retard to 0 for 'Aucun retard' as well
    df_rules['Est_En_Retard'] = df_rules['Catégorie_Règle'].apply(lambda x: 0 if x in ['Pas de retard', 'Aucun retard'] else 1)
    df_rules['Est_Retard_Exagéré'] = (df_rules['Catégorie_Règle'] == 'Retard exagéré').astype(int)


    print(" Règles appliquées:")
    status_counts = df_rules['Catégorie_Règle'].value_counts()
    for status, count in status_counts.items():
        print(f"• {status}: {count} factures ({count/len(df_rules)*100:.1f}%)")

    return df_rules

# Application
df_with_rules = apply_payment_delay_rules(df_clean)

# Save the DataFrame with new columns to an Excel file
output_filename = "BD_avec_regles_paiement.xlsx"
df_with_rules.to_excel(output_filename, index=False)

print(f"Le fichier '{output_filename}' a été créé et est prêt à être téléchargé.")

"""You can download the file directly from the Colab environment using the file browser on the left sidebar. Look for the file named `BD_avec_regles_paiement.xlsx`."""

# Save the DataFrame with corrected categorization to an Excel file
output_filename = "BD_avec_regles_paiement_corrected.xlsx"
df_with_rules.to_excel(output_filename, index=False)

print(f"Le fichier '{output_filename}' a été créé et est prêt à être téléchargé.")

# Save the DataFrame with the latest corrections to an Excel file
output_filename = "BD_avec_regles_paiement_latest.xlsx"
df_with_rules.to_excel(output_filename, index=False)

print(f"Le fichier '{output_filename}' a été créé et est prêt à être téléchargé.")

"""Gestion des Cautions"""

def analyze_caution_compliance(df):
    """Analyse le respect des limites de caution selon vos règles"""
    print(" ANALYSE DES CAUTIONS")
    print("="*30)

    # Calcul de l'encours par client
    client_encours = df.groupby(['Code Client', 'Client']).agg({
        ' T.T.C ': 'sum',  # Encours total
        ' Caution ': 'first',  # Montant caution (identique pour un client)
        'Est_En_Retard': 'sum',  # Nombre factures en retard
        'N° Facture': 'count',  # Nombre total factures
        'Jours_Retard': 'mean',  # Retard moyen
        'Date d\'Emission': 'min',  # Ancienneté relation
        'Catégorie_Règle': lambda x: list(x.unique()) # Aggregate unique delay categories
    }).round(2)

    client_encours.columns = ['Encours_Total', 'Caution', 'Nb_Retards',
                             'Nb_Factures', 'Retard_Moyen', 'Première_Facture', 'Types_Retard']


    # Calculs de dépassement selon VOS règles métier
    client_encours['Caution_Disponible'] = client_encours['Caution'].fillna(0)
    client_encours['Dépassement'] = np.maximum(0,
        client_encours['Encours_Total'] - client_encours['Caution_Disponible']
    )

    # Classification selon vos critères métier
    def classify_client_situation(row):
        """Classification selon règles métier + caution"""
        score_risque = 0

        # Points selon retard moyen
        if row['Retard_Moyen'] > 60:
            score_risque += 5  # Retard exagéré
        elif row['Retard_Moyen'] > 30:
            score_risque += 3  # Retard simple

        # Points selon dépassement caution
        if row['Dépassement'] > 0:
            if row['Caution_Disponible'] > 0:
                score_risque += 4  # Dépasse sa caution
            else:
                score_risque += 2  # Pas de caution mais encours

        # Classification finale selon VOS règles
        if score_risque >= 7:
            return ' BLOCAGE IMMÉDIAT'
        elif score_risque >= 5:
            return ' HAUT RISQUE'
        elif score_risque >= 3:
            return ' SURVEILLANCE'
        else:
            return ' NORMAL'

    client_encours['Classification'] = client_encours.apply(classify_client_situation, axis=1)

    print(" RÉSULTATS CAUTIONS:")
    classification_counts = client_encours['Classification'].value_counts()
    for classif, count in classification_counts.items():
        total_encours = client_encours[client_encours['Classification'] == classif]['Encours_Total'].sum()
        print(f"• {classif}: {count} clients ({total_encours:,.0f} € d'encours)")

    return client_encours

# Analyse des cautions
client_analysis = analyze_caution_compliance(df_with_rules)
# Display clients classified as ' HAUT RISQUE'
haut_risque_clients = client_analysis[client_analysis['Classification'] == ' HAUT RISQUE']
print("Clients classifiés comme ' HAUT RISQUE':")
display(haut_risque_clients)

"""# Tâche 3.1 : Indicateurs Clés

business_metrics.py
"""

def generate_business_kpis(df, client_analysis):
    """Génère les KPIs business selon vos règles métier"""

    kpis = {}
    today = pd.Timestamp.now()

    # 1. KPIs Généraux
    kpis['general'] = {
        'total_factures': len(df),
        'total_ttc': df[' T.T.C '].sum(), # Corrected column name
        'nb_clients': df['Code Client'].nunique(),
        'montant_moyen_facture': df[' T.T.C '].mean() # Corrected column name
    }

    # 2. KPIs selon VOS règles 30/60 jours
    kpis['retards'] = {
        'factures_dans_delais': len(df[df['Catégorie_Règle'] == 'Pas de retard']),
        'factures_retard_simple': len(df[df['Catégorie_Règle'] == 'Retard']),
        'factures_retard_exagere': len(df[df['Catégorie_Règle'] == 'Retard exagéré']),
        'taux_retard_global': df['Est_En_Retard'].mean() * 100,
        'montant_retards_exageres': df[df['Est_Retard_Exagéré'] == 1][' T.T.C '].sum() # Corrected column name
    }

    # 3. KPIs Cautions
    kpis['cautions'] = {
        'clients_avec_caution': len(client_analysis[client_analysis['Caution_Disponible'] > 0]),
        'clients_depassement': len(client_analysis[client_analysis['Dépassement'] > 0]),
        'montant_total_depassement': client_analysis['Dépassement'].sum(),
        'clients_blocage_immediat': len(client_analysis[client_analysis['Classification'] == ' BLOCAGE IMMÉDIAT'])
    }

    # 4. KPIs Temporels
    factures_impayees = df[df['Encaissement'] != 'OUI']
    kpis['temporel'] = {
        'factures_impayees': len(factures_impayees),
        'montant_impaye': factures_impayees[' T.T.C '].sum(), # Corrected column name
        'retard_moyen_jours': factures_impayees['Jours_Retard'].mean(),
        'plus_ancien_impaye': factures_impayees['Jours_Retard'].max()
    }

    return kpis, factures_impayees # Return both kpis and factures_impayees

def print_business_report(kpis, factures_impayees): # Accept factures_impayees as an argument
    """Affiche le rapport business"""
    print("\n" + "="*60)
    print(" RAPPORT BUSINESS - SEMAINE 1")
    print("="*60)

    # KPIs Généraux
    print(f"\n INDICATEURS GÉNÉRAUX:")
    print(f"• Total factures: {kpis['general']['total_factures']:,}")
    print(f"• Chiffre d'affaires total: {kpis['general']['total_ttc']:,.2f} €")
    print(f"• Nombre de clients: {kpis['general']['nb_clients']}")
    print(f"• Montant moyen/facture: {kpis['general']['montant_moyen_facture']:,.2f} €")

    # Retards selon vos règles
    print(f"\n ANALYSE RETARDS (règles 30/60 jours):")
    print(f"• Dans les délais (<30j): {kpis['retards']['factures_dans_delais']} factures")
    print(f"• Retard simple (30-60j): {kpis['retards']['factures_retard_simple']} factures")
    print(f"• Retard exagéré (>60j): {kpis['retards']['factures_retard_exagere']} factures")
    print(f"• Taux de retard global: {kpis['retards']['taux_retard_global']:.1f}%")
    print(f"• Montant retards exagérés: {kpis['retards']['montant_retards_exageres']:,.2f} €")

    # Cautions
    print(f"\n SITUATION CAUTIONS:")
    print(f"• Clients avec caution: {kpis['cautions']['clients_avec_caution']}")
    print(f"• Clients en dépassement: {kpis['cautions']['clients_depassement']}")
    print(f"• Montant total dépassements: {kpis['cautions']['montant_total_depassement']:,.2f} €")
    print(f"• Clients BLOCAGE IMMÉDIAT: {kpis['cautions']['clients_blocage_immediat']}")

    # Situation actuelle
    print(f"\n SITUATION ACTUELLE:")
    print(f"• Factures impayées: {kpis['temporel']['factures_impayees']}")
    print(f"• Montant impayé: {kpis['temporel']['montant_impaye']:,.2f} €")
    print(f"• Retard moyen: {kpis['temporel']['retard_moyen_jours']:.1f} jours")
    # Added a check for empty dataframe to prevent error on max()
    if not factures_impayees.empty:
        print(f"• Plus ancien impayé: {kpis['temporel']['plus_ancien_impaye']} jours")
    else:
        print("• Plus ancien impayé: N/A (aucune facture impayée)")


# Génération du rapport
kpis, factures_impayees = generate_business_kpis(df_with_rules, client_analysis) # Receive both return values
print_business_report(kpis, factures_impayees) # Pass factures_impayees to the print function

"""# Tâche 4.1 : Identification des Actions

identify_priority_actions
"""

def identify_priority_actions(df, client_analysis):
    """Identifie les actions prioritaires selon les règles métier"""

    actions = {
        'urgentes': [],
        'importantes': [],
        'surveillance': []
    }

    # 1. Actions URGENTES (blocage immédiat)
    blocage_clients = client_analysis[
        client_analysis['Classification'] == ' BLOCAGE IMMÉDIAT'
    ]

    for _, client in blocage_clients.iterrows():
        actions['urgentes'].append({
            'client': client.name[1],  # Nom du client
            'code': client.name[0],    # Code client
            'encours': client['Encours_Total'],
            'depassement': client['Dépassement'],
            'action': 'BLOQUER - Suspension livraisons immédiate'
        })

    # 2. Actions IMPORTANTES (retards exagérés sans blocage)
    retards_exageres = df[
        (df['Catégorie_Règle'] == 'Retard exagéré') &
        (df['Encaissement'] != 'OUI')
    ]

    for _, facture in retards_exageres.head(10).iterrows():
        actions['importantes'].append({
            'facture': facture['N° Facture'],
            'client': facture['Client'],
            'montant': facture[' T.T.C '], # Corrected column name
            'jours_retard': facture['Jours_Retard'],
            'action': 'RELANCE DIRECTE - Contact téléphonique direction'
        })

    # 3. SURVEILLANCE (approche des seuils)
    approche_60j = df[
        (df['Jours_Retard'] >= 45) & (df['Jours_Retard'] <= 60) &
        (df['Encaissement'] != 'OUI')
    ]

    for _, facture in approche_60j.head(10).iterrows():
        actions['surveillance'].append({
            'facture': facture['N° Facture'],
            'client': facture['Client'],
            'montant': facture[' T.T.C '], # Corrected column name
            'jours_retard': facture['Jours_Retard'],
            'action': 'PRÉVENTIF - Relance avant passage retard exagéré'
        })

    return actions

# Génération des actions
priority_actions = identify_priority_actions(df_with_rules, client_analysis)

# Display the priority_actions dictionary
display(priority_actions)

import pandas as pd
import numpy as np
from datetime import datetime

# Function to load and perform initial data exploration (modified to be less verbose for a combined script)
def load_and_explore_data(file_path):
    """Loads data and performs basic exploration."""
    import os
    excel_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '../data/updated_BD V2.xlsx'))
    print(f"Chemin absolu du fichier Excel (main flow): {excel_path}")
    df = pd.read_excel(excel_path)
    print(f"Data loaded successfully: {df.shape[0]} rows, {df.shape[1]} columns")
    # You can uncomment these lines if you want to see the full initial audit output
    # print("Available columns:", df.columns.tolist())
    # print("Missing data:\n", df.isnull().sum())
    return df

# Function to clean financial data
def clean_financial_data(df):
    """Nettoie les données financières selon le format français"""
    print("\n NETTOYAGE DES DONNÉES")
    print("="*30)

    df_clean = df.copy()
    initial_rows = len(df_clean)

    # 1. Conversion des montants (format français avec virgules)
    numeric_cols = [' H.T ', ' T.V.A ', ' T.R ', ' T.T.C ', ' Caution ', ' Montant ']

    for col in numeric_cols:
        if col in df_clean.columns:
            df_clean[col] = df_clean[col].astype(str).str.replace(',', '.').str.replace(' ', '')
            df_clean[col] = pd.to_numeric(df_clean[col], errors='coerce')
        else:
            print(f"Column {col} not found during cleaning. Skipping.")

    # 2. Conversion des dates
    date_cols = ["Date d'Emission", 'échéance', 'Date Encaissement']
    for col in date_cols:
        if col in df_clean.columns:
            df_clean[col] = pd.to_datetime(df_clean[col], errors='coerce')
        else:
             print(f"Column {col} not found during date conversion. Skipping.")

    # 3. Suppression des lignes problématiques
    if ' T.T.C ' in df_clean.columns:
        df_clean = df_clean[df_clean[' T.T.C '] > 0].copy() # Added .copy() to avoid SettingWithCopyWarning
    else:
        print("' T.T.C ' column not found. Skipping filtering by positive TTC.")

    if "Date d'Emission" in df_clean.columns and 'échéance' in df_clean.columns:
         df_clean = df_clean[df_clean['Date d\'Emission'] <= df_clean['échéance']].copy() # Added .copy()
    else:
        print("'Date d\'Emission' or 'échéance' column not found. Skipping filtering by date order.")

    print(f" Nettoyage terminé: {initial_rows - len(df_clean)} lignes supprimées, {len(df_clean)} conservées")
    return df_clean

# Function to apply payment delay rules
def apply_payment_delay_rules(df):
    """Applique les règles métier 30/60 jours"""
    print("\nAPPLICATION DES RÈGLES MÉTIER")
    print("="*40)

    df_rules = df.copy()
    today = pd.Timestamp.now()

    def calculate_delay_status(row):
        """Calcule le statut selon vos règles: <30j, 30-60j, >60j"""
        echeance = row['échéance']

        if pd.isna(echeance):
            return 'Échéance manquante', 0, 'Indéterminé'

        if row['Encaissement'] == 'OUI' and pd.notna(row['Date Encaissement']):
            days_late = (row['Date Encaissement'] - echeance).days
        else:
            days_late = (today - echeance).days

        if days_late < 0:
            return 'Payée avant échéance', days_late, 'Aucun retard'
        elif days_late <= 30:
            return 'Dans les délais', days_late, 'Pas de retard'
        elif days_late <= 60:
            return 'En retard', days_late, 'Retard'
        else:
            return 'Retard exagéré', days_late, 'Retard exagéré'

    df_rules[['Statut_Détaillé', 'Jours_Retard', 'Catégorie_Règle']] = df_rules.apply(
        calculate_delay_status, axis=1, result_type='expand'
    )

    df_rules['Est_En_Retard'] = df_rules['Catégorie_Règle'].apply(lambda x: 0 if x in ['Pas de retard', 'Aucun retard'] else 1)
    df_rules['Est_Retard_Exagéré'] = (df_rules['Catégorie_Règle'] == 'Retard exagéré').astype(int)

    print(" Règles appliquées:")
    status_counts = df_rules['Catégorie_Règle'].value_counts()
    for status, count in status_counts.items():
        print(f"• {status}: {count} factures") # Removed percentage for brevity in combined output

    return df_rules

# Function to analyze caution compliance
def analyze_caution_compliance(df):
    """Analyse le respect des limites de caution selon vos règles"""
    print("\n ANALYSE DES CAUTIONS")
    print("="*30)

    client_encours = df.groupby(['Code Client', 'Client']).agg({
        ' T.T.C ': 'sum',
        ' Caution ': 'first',
        'Est_En_Retard': 'sum',
        'N° Facture': 'count',
        'Jours_Retard': 'mean',
        'Date d\'Emission': 'min',
        'Catégorie_Règle': lambda x: list(x.unique())
    }).round(2)

    client_encours.columns = ['Encours_Total', 'Caution', 'Nb_Retards',
                             'Nb_Factures', 'Retard_Moyen', 'Première_Facture', 'Types_Retard']

    client_encours['Caution_Disponible'] = client_encours['Caution'].fillna(0)
    client_encours['Dépassement'] = np.maximum(0,
        client_encours['Encours_Total'] - client_encours['Caution_Disponible']
    )

    def classify_client_situation(row):
        score_risque = 0
        if row['Retard_Moyen'] > 60:
            score_risque += 5
        elif row['Retard_Moyen'] > 30:
            score_risque += 3

        if row['Dépassement'] > 0:
            if row['Caution_Disponible'] > 0:
                score_risque += 4
            else:
                score_risque += 2

        if score_risque >= 7:
            return ' BLOCAGE IMMÉDIAT'
        elif score_risque >= 5:
            return ' HAUT RISQUE'
        elif score_risque >= 3:
            return ' SURVEILLANCE'
        else:
            return ' NORMAL'

    client_encours['Classification'] = client_encours.apply(classify_client_situation, axis=1)

    print(" RÉSULTATS CAUTIONS:")
    classification_counts = client_encours['Classification'].value_counts()
    for classif, count in classification_counts.items():
        total_encours = client_encours[client_encours['Classification'] == classif]['Encours_Total'].sum()
        print(f"• {classif}: {count} clients ({total_encours:,.0f} € d'encours)")

    return client_encours

# Function to generate business KPIs
def generate_business_kpis(df, client_analysis):
    """Génère les KPIs business selon vos règles métier"""
    print("\n RAPPORT BUSINESS - SEMAINE 1")
    print("="*60)

    kpis = {}
    factures_impayees = df[df['Encaissement'] != 'OUI'].copy() # Added .copy()

    # 1. KPIs Généraux
    kpis['general'] = {
        'total_factures': len(df),
        'total_ttc': df[' T.T.C '].sum(),
        'nb_clients': df['Code Client'].nunique(),
        'montant_moyen_facture': df[' T.T.C '].mean()
    }
    print(f"\n INDICATEURS GÉNÉRAUX:")
    print(f"• Total factures: {kpis['general']['total_factures']:,}")
    print(f"• Chiffre d'affaires total: {kpis['general']['total_ttc']:,.2f} €")
    print(f"• Nombre de clients: {kpis['general']['nb_clients']}")
    print(f"• Montant moyen/facture: {kpis['general']['montant_moyen_facture']:,.2f} €")


    # 2. KPIs selon VOS règles 30/60 jours
    kpis['retards'] = {
        'factures_dans_delais': len(df[df['Catégorie_Règle'] == 'Pas de retard']),
        'factures_retard_simple': len(df[df['Catégorie_Règle'] == 'Retard']),
        'factures_retard_exagere': len(df[df['Catégorie_Règle'] == 'Retard exagéré']),
        'taux_retard_global': df['Est_En_Retard'].mean() * 100,
        'montant_retards_exageres': df[df['Est_Retard_Exagéré'] == 1][' T.T.C '].sum()
    }
    print(f"\n ANALYSE RETARDS (règles 30/60 jours):")
    print(f"• Dans les délais (<30j): {kpis['retards']['factures_dans_delais']} factures")
    print(f"• Retard simple (30-60j): {kpis['retards']['factures_retard_simple']} factures")
    print(f"• Retard exagéré (>60j): {kpis['retards']['factures_retard_exagere']} factures")
    print(f"• Taux de retard global: {kpis['retards']['taux_retard_global']:.1f}%")
    print(f"• Montant retards exagérés: {kpis['retards']['montant_retards_exageres']:,.2f} €")


    # 3. KPIs Cautions
    kpis['cautions'] = {
        'clients_avec_caution': len(client_analysis[client_analysis['Caution_Disponible'] > 0]),
        'clients_depassement': len(client_analysis[client_analysis['Dépassement'] > 0]),
        'montant_total_depassement': client_analysis['Dépassement'].sum(),
        'clients_blocage_immediat': len(client_analysis[client_analysis['Classification'] == ' BLOCAGE IMMÉDIAT'])
    }
    print(f"\n SITUATION CAUTIONS:")
    print(f"• Clients avec caution: {kpis['cautions']['clients_avec_caution']}")
    print(f"• Clients en dépassement: {kpis['cautions']['clients_depassement']}")
    print(f"• Montant total dépassements: {kpis['cautions']['montant_total_depassement']:,.2f} €")
    print(f"• Clients BLOCAGE IMMÉDIAT: {kpis['cautions']['clients_blocage_immediat']}")


    # 4. KPIs Temporels
    kpis['temporel'] = {
        'factures_impayees': len(factures_impayees),
        'montant_impaye': factures_impayees[' T.T.C '].sum(),
        'retard_moyen_jours': factures_impayees['Jours_Retard'].mean(),
        'plus_ancien_impaye': factures_impayees['Jours_Retard'].max() if not factures_impayees.empty else None # Handle empty case
    }
    print(f"\n SITUATION ACTUELLE:")
    print(f"• Factures impayées: {kpis['temporel']['factures_impayees']}")
    print(f"• Montant impayé: {kpis['temporel']['montant_impaye']:,.2f} €")
    print(f"• Retard moyen: {kpis['temporel']['retard_moyen_jours']:.1f} jours")
    print(f"• Plus ancien impayé: {kpis['temporel']['plus_ancien_impaye']} jours" if kpis['temporel']['plus_ancien_impaye'] is not None else "• Plus ancien impayé: N/A (aucune facture impayée)")


    return kpis, factures_impayees # Return both kpis and factures_impayees


# Function to identify priority actions
def identify_priority_actions(df, client_analysis):
    """Identifie les actions prioritaires selon les règles métier"""
    print("\n ACTIONS PRIORITAIRES")
    print("="*30)

    actions = {
        'urgentes': [],
        'importantes': [],
        'surveillance': []
    }

    # 1. Actions URGENTES (blocage immédiat)
    blocage_clients = client_analysis[
        client_analysis['Classification'] == ' BLOCAGE IMMÉDIAT'
    ]

    for _, client in blocage_clients.iterrows():
        actions['urgentes'].append({
            'client': client.name[1],
            'code': client.name[0],
            'encours': client['Encours_Total'],
            'depassement': client['Dépassement'],
            'action': 'BLOQUER - Suspension livraisons immédiate'
        })

    # 2. Actions IMPORTANTES (retards exagérés sans blocage)
    retards_exageres = df[
        (df['Catégorie_Règle'] == 'Retard exagéré') &
        (df['Encaissement'] != 'OUI')
    ].copy() # Added .copy()


    for _, facture in retards_exageres.head(10).iterrows():
        actions['importantes'].append({
            'facture': facture['N° Facture'],
            'client': facture['Client'],
            'montant': facture[' T.T.C '],
            'jours_retard': facture['Jours_Retard'],
            'action': 'RELANCE DIRECTE - Contact téléphonique direction'
        })

    # 3. SURVEILLANCE (approche des seuils)
    approche_60j = df[
        (df['Jours_Retard'] >= 45) & (df['Jours_Retard'] <= 60) &
        (df['Encaissement'] != 'OUI')
    ].copy() # Added .copy()


    for _, facture in approche_60j.head(10).iterrows():
        actions['surveillance'].append({
            'facture': facture['N° Facture'],
            'client': facture['Client'],
            'montant': facture[' T.T.C '],
            'jours_retard': facture['Jours_Retard'],
            'action': 'PRÉVENTIF - Relance avant passage retard exagéré'
        })

    print(" Actions identifiées.")
    # You can uncomment this to display the actions dictionary
    # display(actions)

    return actions


# --- Main Execution Flow ---
file_path = "../data/updated_BD V2.xlsx"

# 1. Load and Clean Data
df = load_and_explore_data(file_path)
df_clean = clean_financial_data(df)

# 2. Apply Payment Delay Rules
df_with_rules = apply_payment_delay_rules(df_clean)

# 3. Analyze Caution Compliance
client_analysis = analyze_caution_compliance(df_with_rules)

# 4. Generate Business KPIs (and print report)
kpis, factures_impayees = generate_business_kpis(df_with_rules, client_analysis)

# 5. Identify Priority Actions
priority_actions = identify_priority_actions(df_with_rules, client_analysis)

print("\n--- Analysis Complete ---")
print("Key DataFrames available: df, df_clean, df_with_rules, client_analysis")
print("Key results available: kpis (dict), factures_impayees (DataFrame), priority_actions (dict)")

"""# Vizs Dynamiques

1. Interactive Bar Chart of Clients by Risk Classification
"""

import plotly.express as px

# 1. Interactive Bar Chart of Clients by Risk Classification
# Ensure 'Classification' column exists in client_analysis and is not empty
if 'Classification' in client_analysis.columns and not client_analysis.empty:
    # Explicitly create DataFrame for bar chart to avoid potential reset_index() ambiguity
    classification_counts_df = client_analysis['Classification'].value_counts().reset_index()
    # Rename columns to be explicit
    classification_counts_df.columns = ['Classification', 'Count']

    # print("Columns for bar chart:", classification_counts_df.columns.tolist()) # Debugging line

    fig_classification = px.bar(
        classification_counts_df,
        x='Classification',  # Classification labels are now explicitly in 'Classification'
        y='Count', # Counts are now explicitly in 'Count'
        title='Distribution of Clients by Risk Classification',
        labels={'Classification': 'Risk Classification', 'Count': 'Number of Clients'}, # Update labels accordingly
        color='Classification', # Color bars by classification
        color_discrete_sequence=px.colors.qualitative.Vivid # Use a vibrant color sequence
    )
    fig_classification.update_layout(xaxis_title="Risk Classification", yaxis_title="Number of Clients")
    fig_classification.show()
else:
    print("Cannot generate Client Risk Classification chart: 'Classification' column not found or client_analysis is empty.")

"""2. Interactive Scatter Plot of Encours vs. Retard Moyen, Colored by Classification"""

import plotly.express as px
# 2. Interactive Scatter Plot of Encours vs. Retard Moyen, Colored by Classification
# Ensure required columns exist and client_analysis is not empty
required_cols_scatter = ['Encours_Total', 'Retard_Moyen', 'Classification']
if all(col in client_analysis.columns for col in required_cols_scatter) and not client_analysis.empty:
    # Explicitly reset index before passing to Plotly Express
    client_analysis_reset = client_analysis.reset_index()

    # print("Columns for scatter plot:", client_analysis_reset.columns.tolist()) # Debugging line
    # Ensure 'Client' column exists after reset_index
    if 'Client' in client_analysis_reset.columns:
        fig_encours_retard = px.scatter(
            client_analysis_reset, # Use the DataFrame with explicitly reset index
            x='Retard_Moyen',
            y='Encours_Total',
            color='Classification', # Color points by classification
            hover_name='Client', # Now 'Client' is a column
            title='Client Encours vs. Average Delay, Colored by Risk',
            labels={'Retard_Moyen': 'Average Delay (Days)', 'Encours_Total': 'Total Encours (€)'},
            size='Encours_Total', # Size points by encours
            color_discrete_sequence=px.colors.qualitative.Vivid # Use a vibrant color sequence
        )
        fig_encours_retard.update_layout(xaxis_title="Average Delay (Days)", yaxis_title="Total Encours (€)")
        fig_encours_retard.show()
    else:
        print("Cannot generate Encours vs. Average Delay scatter plot: 'Client' column not found after explicitly resetting index.")
else:
    print("Cannot generate Encours vs. Average Delay scatter plot: One or more required columns not found or client_analysis is empty.")

"""3. Interactive Treemap of Total Encours by Client, Colored by Risk"""

import plotly.express as px
# 3. Interactive Treemap of Total Encours by Client, Colored by Risk
# Ensure required columns exist and client_analysis is not empty
required_cols_treemap = ['Encours_Total', 'Classification']
if all(col in client_analysis.columns for col in required_cols_treemap) and not client_analysis.empty:
    # Explicitly reset index before passing to Plotly Express
    client_analysis_reset = client_analysis.reset_index()

    # print("Columns for treemap:", client_analysis_reset.columns.tolist()) # Debugging line
    # Ensure 'Client' column exists after reset_index
    if 'Client' in client_analysis_reset.columns:
        fig_treemap = px.treemap(
            client_analysis_reset, # Use the DataFrame with explicitly reset index
            path=[px.Constant("All Clients"), 'Classification', 'Client'], # Now 'Client' is a column
            values='Encours_Total', # Size based on Encours
            color='Classification', # Color based on Classification
            title='Total Encours by Client, Colored by Risk Classification',
            color_discrete_sequence=px.colors.qualitative.Vivid # Use a vibrant color sequence
        )
        fig_treemap.update_layout(margin=dict(t=50, l=25, r=25, b=25))
        fig_treemap.show()
    else:
        print("Cannot generate Encours Treemap: 'Client' column not found after explicitly resetting index.")
else:
    print("Cannot generate Encours Treemap: One or more required columns not found or client_analysis is empty.")

"""### Interactive Time Series of Total Encours"""

import plotly.express as px

# Prepare data for time series: Group by Date d'Emission and sum T.T.C
# Ensure 'Date d\'Emission' and ' T.T.C ' columns exist and are not empty
if "Date d'Emission" in df_with_rules.columns and ' T.T.C ' in df_with_rules.columns and not df_with_rules.empty:
    # Aggregate by date and sum the total amount
    daily_encours = df_with_rules.groupby(df_with_rules["Date d'Emission"].dt.date)[' T.T.C '].sum().reset_index()
    daily_encours.columns = ['Date', 'Total_Encours']

    fig_time_series = px.line(
        daily_encours,
        x='Date',
        y='Total_Encours',
        title='Total Encours Over Time',
        labels={'Date': 'Date', 'Total_Encours': 'Total Encours (€)'},
        color_discrete_sequence=[px.colors.qualitative.Vivid[0]] # Use a vibrant color
    )
    fig_time_series.update_layout(xaxis_title="Date", yaxis_title="Total Encours (€)")
    fig_time_series.show()
else:
    print("Cannot generate Time Series chart: Required columns not found or df_with_rules is empty.")

"""### Interactive Bar Chart of Top 10 Clients by Encours"""

import plotly.express as px

# Prepare data for Top N Clients: Sort client_analysis by Encours_Total
# Ensure 'Encours_Total' and 'Client' columns exist and client_analysis is not empty
# Reset index to make 'Code Client' and 'Client' regular columns
client_analysis_reset = client_analysis.reset_index()

# Now check for required columns in the reset DataFrame
if 'Encours_Total' in client_analysis_reset.columns and 'Client' in client_analysis_reset.columns and not client_analysis_reset.empty:
    # Sort by total encours and get the top 10
    top_n_clients = client_analysis_reset.sort_values(by='Encours_Total', ascending=False).head(10)

    fig_top_clients = px.bar(
        top_n_clients,
        x='Client',
        y='Encours_Total',
        title='Top 10 Clients by Total Encours',
        labels={'Client': 'Client', 'Encours_Total': 'Total Encours (€)'},
        color='Client', # Color bars by client
        color_discrete_sequence=px.colors.qualitative.Vivid # Use a vibrant color sequence
    )
    fig_top_clients.update_layout(xaxis_title="Client", yaxis_title="Total Encours (€)")
    fig_top_clients.show()
else:
     # Modified message to reflect the check is on the reset DataFrame
     print("Cannot generate Top 10 Clients chart: Required columns not found in the reset DataFrame or client_analysis_reset is empty.")

"""### Interactive Distribution of Days Late for Unpaid Invoices"""

import plotly.express as px

# Prepare data for Distribution of Days Late: Use the factures_impayees DataFrame
# Ensure 'Jours_Retard' and 'Catégorie_Règle' columns exist and factures_impayees is not empty
if 'Jours_Retard' in factures_impayees.columns and 'Catégorie_Règle' in factures_impayees.columns and not factures_impayees.empty:
    fig_days_late_dist = px.histogram(
        factures_impayees,
        x='Jours_Retard',
        color='Catégorie_Règle', # Color bars by delay category
        title='Distribution of Days Late for Unpaid Invoices',
        labels={'Jours_Retard': 'Days Late', 'count': 'Number of Invoices'},
        color_discrete_sequence=px.colors.qualitative.Vivid # Use a vibrant color sequence
    )
    fig_days_late_dist.update_layout(xaxis_title="Days Late", yaxis_title="Number of Invoices")
    fig_days_late_dist.show()
else:
    print("Cannot generate Days Late Distribution chart: Required columns not found or factures_impayees is empty.")

import pandas as pd
import numpy as np
from datetime import datetime

# Function to load and perform initial data exploration
def load_and_explore_data(file_path):
    """Loads data and performs basic exploration."""
    import os
    excel_path = os.path.abspath(os.path.join(os.path.dirname(__file__), file_path))
    print(f"Chemin absolu du fichier Excel (final flow): {excel_path}")
    df = pd.read_excel(excel_path)
    print(f"Data loaded successfully: {df.shape[0]} rows, {df.shape[1]} columns")
    return df

# Function to clean financial data
def clean_financial_data(df):
    """Nettoie les données financières selon le format français"""
    print("\nNETTOYAGE DES DONNÉES")
    print("="*30)

    df_clean = df.copy()
    initial_rows = len(df_clean)

    # 1. Conversion des montants (format français avec virgules)
    numeric_cols = [' H.T ', ' T.V.A ', ' T.R ', ' T.T.C ', ' Caution ', ' Montant ']

    for col in numeric_cols:
        if col in df_clean.columns:
            df_clean[col] = df_clean[col].astype(str).str.replace(',', '.').str.replace(' ', '')
            df_clean[col] = pd.to_numeric(df_clean[col], errors='coerce')
        else:
            print(f"Column {col} not found during cleaning. Skipping.")

    # 2. Conversion des dates
    date_cols = ["Date d'Emission", 'échéance', 'Date Encaissement']
    for col in date_cols:
        if col in df_clean.columns:
            df_clean[col] = pd.to_datetime(df_clean[col], errors='coerce')
        else:
             print(f"Column {col} not found during date conversion. Skipping.")

    # 3. Suppression des lignes problématiques
    if ' T.T.C ' in df_clean.columns:
        df_clean = df_clean[df_clean[' T.T.C '] > 0].copy()
    else:
        print("' T.T.C ' column not found. Skipping filtering by positive TTC.")

    if "Date d'Emission" in df_clean.columns and 'échéance' in df_clean.columns:
         df_clean = df_clean[df_clean['Date d\'Emission'] <= df_clean['échéance']].copy()
    else:
        print("'Date d\'Emission' or 'échéance' column not found. Skipping filtering by date order.")

    print(f" Nettoyage terminé: {initial_rows - len(df_clean)} lignes supprimées, {len(df_clean)} conservées")
    return df_clean

# Function to apply payment delay rules
def apply_payment_delay_rules(df):
    """Applique les règles métier 30/60 jours"""
    print("\nAPPLICATION DES RÈGLES MÉTIER")
    print("="*40)

    df_rules = df.copy()
    today = pd.Timestamp.now()

    def calculate_delay_status(row):
        """Calcule le statut selon vos règles: <30j, 30-60j, >60j"""
        echeance = row['échéance']

        if pd.isna(echeance):
            return 'Échéance manquante', 0, 'Indéterminé'

        if row['Encaissement'] == 'OUI' and pd.notna(row['Date Encaissement']):
            days_late = (row['Date Encaissement'] - echeance).days
        else:
            days_late = (today - echeance).days

        if days_late < 0:
            return 'Payée avant échéance', days_late, 'Aucun retard'
        elif days_late <= 30:
            return 'Dans les délais', days_late, 'Pas de retard'
        elif days_late <= 60:
            return 'En retard', days_late, 'Retard'
        else:
            return 'Retard exagéré', days_late, 'Retard exagéré'

    df_rules[['Statut_Détaillé', 'Jours_Retard', 'Catégorie_Règle']] = df_rules.apply(
        calculate_delay_status, axis=1, result_type='expand'
    )

    df_rules['Est_En_Retard'] = df_rules['Catégorie_Règle'].apply(lambda x: 0 if x in ['Pas de retard', 'Aucun retard'] else 1)
    df_rules['Est_Retard_Exagéré'] = (df_rules['Catégorie_Règle'] == 'Retard exagéré').astype(int)

    print(" Règles appliquées:")
    status_counts = df_rules['Catégorie_Règle'].value_counts()
    for status, count in status_counts.items():
        print(f"• {status}: {count} factures")

    return df_rules

# Function to analyze caution compliance
def analyze_caution_compliance(df):
    """Analyse le respect des limites de caution selon vos règles"""
    print("\n ANALYSE DES CAUTIONS")
    print("="*30)

    client_encours = df.groupby(['Code Client', 'Client']).agg({
        ' T.T.C ': 'sum',
        ' Caution ': 'first',
        'Est_En_Retard': 'sum',
        'N° Facture': 'count',
        'Jours_Retard': 'mean',
        'Date d\'Emission': 'min',
        'Catégorie_Règle': lambda x: list(x.unique())
    }).round(2)

    client_encours.columns = ['Encours_Total', 'Caution', 'Nb_Retards',
                             'Nb_Factures', 'Retard_Moyen', 'Première_Facture', 'Types_Retard']

    client_encours['Caution_Disponible'] = client_encours['Caution'].fillna(0)
    client_encours['Dépassement'] = np.maximum(0,
        client_encours['Encours_Total'] - client_encours['Caution_Disponible']
    )

    def classify_client_situation(row):
        score_risque = 0
        if row['Retard_Moyen'] > 60:
            score_risque += 5
        elif row['Retard_Moyen'] > 30:
            score_risque += 3

        if row['Dépassement'] > 0:
            if row['Caution_Disponible'] > 0:
                score_risque += 4
            else:
                score_risque += 2

        if score_risque >= 7:
            return ' BLOCAGE IMMÉDIAT'
        elif score_risque >= 5:
            return ' HAUT RISQUE'
        elif score_risque >= 3:
            return ' SURVEILLANCE'
        else:
            return ' NORMAL'

    client_encours['Classification'] = client_encours.apply(classify_client_situation, axis=1)

    print(" RÉSULTATS CAUTIONS:")
    classification_counts = client_encours['Classification'].value_counts()
    for classif, count in classification_counts.items():
        total_encours = client_encours[client_encours['Classification'] == classif]['Encours_Total'].sum()
        print(f"• {classif}: {count} clients ({total_encours:,.0f} € d'encours)")

    return client_encours

# Function to generate business KPIs
def generate_business_kpis(df, client_analysis):
    """Génère les KPIs business selon vos règles métier"""
    print("\n RAPPORT BUSINESS - SEMAINE 1")
    print("="*60)

    kpis = {}
    factures_impayees = df[df['Encaissement'] != 'OUI'].copy()

    # 1. KPIs Généraux
    kpis['general'] = {
        'total_factures': len(df),
        'total_ttc': df[' T.T.C '].sum(),
        'nb_clients': df['Code Client'].nunique(),
        'montant_moyen_facture': df[' T.T.C '].mean()
    }
    print(f"\n INDICATEURS GÉNÉRAUX:")
    print(f"• Total factures: {kpis['general']['total_factures']:,}")
    print(f"• Chiffre d'affaires total: {kpis['general']['total_ttc']:,.2f} €")
    print(f"• Nombre de clients: {kpis['general']['nb_clients']}")
    print(f"• Montant moyen/facture: {kpis['general']['montant_moyen_facture']:,.2f} €")


    # 2. KPIs selon VOS règles 30/60 jours
    kpis['retards'] = {
        'factures_dans_delais': len(df[df['Catégorie_Règle'] == 'Pas de retard']),
        'factures_retard_simple': len(df[df['Catégorie_Règle'] == 'Retard']),
        'factures_retard_exagere': len(df[df['Catégorie_Règle'] == 'Retard exagéré']),
        'taux_retard_global': df['Est_En_Retard'].mean() * 100,
        'montant_retards_exageres': df[df['Est_Retard_Exagéré'] == 1][' T.T.C '].sum()
    }
    print(f"\n ANALYSE RETARDS (règles 30/60 jours):")
    print(f"• Dans les délais (<30j): {kpis['retards']['factures_dans_delais']} factures")
    print(f"• Retard simple (30-60j): {kpis['retards']['factures_retard_simple']} factures")
    print(f"• Retard exagéré (>60j): {kpis['retards']['factures_retard_exagere']} factures")
    print(f"• Taux de retard global: {kpis['retards']['taux_retard_global']:.1f}%")
    print(f"• Montant retards exagérés: {kpis['retards']['montant_retards_exageres']:,.2f} €")


    # 3. KPIs Cautions
    kpis['cautions'] = {
        'clients_avec_caution': len(client_analysis[client_analysis['Caution_Disponible'] > 0]),
        'clients_depassement': len(client_analysis[client_analysis['Dépassement'] > 0]),
        'montant_total_depassement': client_analysis['Dépassement'].sum(),
        'clients_blocage_immediat': len(client_analysis[client_analysis['Classification'] == ' BLOCAGE IMMÉDIAT'])
    }
    print(f"\n SITUATION CAUTIONS:")
    print(f"• Clients avec caution: {kpis['cautions']['clients_avec_caution']}")
    print(f"• Clients en dépassement: {kpis['cautions']['clients_depassement']}")
    print(f"• Montant total dépassements: {kpis['cautions']['montant_total_depassement']:,.2f} €")
    print(f"• Clients BLOCAGE IMMÉDIAT: {kpis['cautions']['clients_blocage_immediat']}")


    # 4. KPIs Temporels
    kpis['temporel'] = {
        'factures_impayees': len(factures_impayees),
        'montant_impaye': factures_impayees[' T.T.C '].sum(),
        'retard_moyen_jours': factures_impayees['Jours_Retard'].mean(),
        'plus_ancien_impaye': factures_impayees['Jours_Retard'].max() if not factures_impayees.empty else None
    }
    print(f"\n SITUATION ACTUELLE:")
    print(f"• Factures impayées: {kpis['temporel']['factures_impayees']}")
    print(f"• Montant impayé: {kpis['temporel']['montant_impaye']:,.2f} €")
    print(f"• Retard moyen: {kpis['temporel']['retard_moyen_jours']:.1f} jours")
    print(f"• Plus ancien impayé: {kpis['temporel']['plus_ancien_impaye']} jours" if kpis['temporel']['plus_ancien_impaye'] is not None else "• Plus ancien impayé: N/A (aucune facture impayée)")


    return kpis, factures_impayees

# Function to identify priority actions
def identify_priority_actions(df, client_analysis):
    """Identifie les actions prioritaires selon les règles métier"""
    print("\n ACTIONS PRIORITAIRES")
    print("="*30)

    actions = {
        'urgentes': [],
        'importantes': [],
        'surveillance': []
    }

    # 1. Actions URGENTES (blocage immédiat)
    blocage_clients = client_analysis[
        client_analysis['Classification'] == ' BLOCAGE IMMÉDIAT'
    ]

    for _, client in blocage_clients.iterrows():
        actions['urgentes'].append({
            'client': client.name[1],
            'code': client.name[0],
            'encours': client['Encours_Total'],
            'depassement': client['Dépassement'],
            'action': 'BLOQUER - Suspension livraisons immédiate'
        })

    # 2. Actions IMPORTANTES (retards exagérés sans blocage)
    retards_exageres = df[
        (df['Catégorie_Règle'] == 'Retard exagéré') &
        (df['Encaissement'] != 'OUI')
    ].copy()


    for _, facture in retards_exageres.head(10).iterrows():
        actions['importantes'].append({
            'facture': facture['N° Facture'],
            'client': facture['Client'],
            'montant': facture[' T.T.C '],
            'jours_retard': facture['Jours_Retard'],
            'action': 'RELANCE DIRECTE - Contact téléphonique direction'
        })

    # 3. SURVEILLANCE (approche des seuils)
    approche_60j = df[
        (df['Jours_Retard'] >= 45) & (df['Jours_Retard'] <= 60) &
        (df['Encaissement'] != 'OUI')
    ].copy()


    for _, facture in approche_60j.head(10).iterrows():
        actions['surveillance'].append({
            'facture': facture['N° Facture'],
            'client': facture['Client'],
            'montant': facture[' T.T.C '],
            'jours_retard': facture['Jours_Retard'],
            'action': 'PRÉVENTIF - Relance avant passage retard exagéré'
        })

    print(" Actions identifiées.")
    return actions

# --- Main Execution Flow ---
file_path = "../data/updated_BD V2.xlsx"

# 1. Load and Clean Data
df = load_and_explore_data(file_path)
df_clean = clean_financial_data(df)

# 2. Apply Payment Delay Rules
df_with_rules = apply_payment_delay_rules(df_clean)

# 3. Analyze Caution Compliance
client_analysis = analyze_caution_compliance(df_with_rules)

# 4. Generate Business KPIs (and print report)
kpis, factures_impayees = generate_business_kpis(df_with_rules, client_analysis)

# 5. Identify Priority Actions
priority_actions = identify_priority_actions(df_with_rules, client_analysis)

print("\n--- Analysis Complete ---")
print("Key DataFrames available: df, df_clean, df_with_rules, client_analysis")
print("Key results available: kpis (dict), factures_impayees (DataFrame), priority_actions (dict)")