# -*- coding: utf-8 -*-
"""Week2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OQxxA-_Dvzkm9rCXWjRiIY5AiE7MqR6T

# 1. IMPORTS ET CONFIGURATION
"""

import pandas as pd
import numpy as np
from datetime import datetime
from IPython.display import display

# Visualisation statique
import matplotlib.pyplot as plt
import seaborn as sns

# Visualisation interactive
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

df = pd.read_excel("BD_avec_regles_paiement_latest.xlsx")
# Conversion des colonnes de date
date_cols = ["Date d'Emission", 'échéance', 'Date Encaissement']
for col in date_cols:
    if col in df.columns:
        df[col] = pd.to_datetime(df[col], errors='coerce')

"""# 2. FONCTIONS D'ANALYSE ET DE VISUALISATION

2.1 Histogrammes et distribution des retards
"""

def plot_delay_distributions(df):
    print("\n HISTOGRAMMES DES RETARDS")
    unpaid_invoices = df[df['Encaissement'] != 'OUI']

    if len(unpaid_invoices) == 0:
        print("Aucune facture impayée à analyser")
        return

    # Plot 1: Distribution des jours de retard (Seaborn)
    plt.figure(figsize=(10, 6))
    sns.histplot(data=unpaid_invoices, x='Jours_Retard', bins=30, kde=True, color='skyblue')
    plt.title('Distribution des jours de retard (Seaborn)')
    plt.xlabel('Jours de retard')
    plt.ylabel('Nombre de factures')
    plt.show()
    plt.close() # Close the plot

    # Plot 2: Distribution des retards par catégorie (Seaborn Boxplot)
    plt.figure(figsize=(10, 6))
    sns.boxplot(data=unpaid_invoices, x='Catégorie_Règle', y='Jours_Retard', hue='Catégorie_Règle', palette='viridis', legend=False)
    plt.title('Distribution des retards par catégorie')
    plt.xlabel('Catégorie de retard')
    plt.ylabel('Jours de retard')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()
    plt.close() # Close the plot

    # Plot 3: Densité des retards par catégorie (Seaborn Violinplot)
    plt.figure(figsize=(10, 6))
    sns.violinplot(data=unpaid_invoices, x='Catégorie_Règle', y='Jours_Retard', hue='Catégorie_Règle', palette='plasma', legend=False)
    plt.title('Densité des retards par catégorie')
    plt.xlabel('Catégorie de retard')
    plt.ylabel('Jours de retard')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()
    plt.close() # Close the plot

    # Plot 4: Distribution cumulative des retards (Seaborn)
    plt.figure(figsize=(10, 6))
    sns.histplot(data=unpaid_invoices, x='Jours_Retard', bins=30, cumulative=True, stat='percent', color='salmon')
    plt.title('Distribution cumulative des retards')
    plt.xlabel('Jours de retard')
    plt.ylabel('Pourcentage cumulé de factures')
    plt.axvline(x=30, color='red', linestyle='--', label='Seuil 30 jours')
    plt.axvline(x=60, color='green', linestyle='--', label='Seuil 60 jours')
    plt.legend()
    plt.show()
    plt.close() # Close the plot


    # Plot 5: Distribution interactive des jours de retard (Plotly)
    fig = px.histogram(
        unpaid_invoices,
        x='Jours_Retard',
        color='Catégorie_Règle',
        nbins=50,
        title='Distribution interactive des jours de retard',
        labels={'Jours_Retard': 'Jours de retard', 'count': 'Nombre de factures'},
        marginal='box',
        color_discrete_sequence=px.colors.qualitative.Bold
    )
    fig.update_layout(barmode='overlay')
    fig.update_traces(opacity=0.75)
    fig.show()

# Assuming 'df' is your DataFrame
plot_delay_distributions(df)

"""# 2.2 Retards par segment client"""

def plot_delay_by_segment(df):
    print("\n RETARDS PAR SEGMENT CLIENT")

    if 'Segment' not in df.columns:
        client_stats = df.groupby('Client').agg({
            ' T.T.C ': ['mean', 'count'],
            'Jours_Retard': 'mean'
        }).reset_index()

        client_stats.columns = ['Client', 'CA_moyen', 'Nb_factures', 'Retard_moyen']
        client_stats['Segment'] = pd.cut(
            client_stats['CA_moyen'],
            bins=[0, 1000, 5000, float('inf')],
            labels=['Petit', 'Moyen', 'Gros']
        )
        df = df.merge(client_stats[['Client', 'Segment']], on='Client', how='left')

    delay_proportions = df.groupby('Segment').agg({
        'Est_En_Retard': 'mean',
        'Est_Retard_Exagéré': 'mean',
        ' T.T.C ': 'count'
    }).reset_index()

    delay_proportions.columns = ['Segment', 'Taux_retard', 'Taux_retard_exagere', 'Nb_factures']

    plt.figure(figsize=(12, 6))
    sns.barplot(data=delay_proportions, x='Segment', y='Taux_retard')
    plt.title('Proportion de factures en retard par segment client')
    plt.xlabel('Segment client')
    plt.ylabel('Proportion de factures en retard')
    plt.ylim(0, 1)
    plt.show()

    fig = px.bar(
        delay_proportions,
        x='Segment',
        y=['Taux_retard', 'Taux_retard_exagere'],
        title='Taux de retard par segment client',
        labels={'value': 'Taux', 'variable': 'Type de retard'},
        barmode='group'
    )
    fig.show()
plot_delay_by_segment(df)

"""# 2.3 Évolution du retard moyen par mois"""

def plot_delay_trends(df):
    print("\n TENDANCES TEMPORELLES DES RETARDS")

    df['Mois_Emission'] = df["Date d'Emission"].dt.to_period('M').dt.strftime('%Y-%m')

    monthly_stats = df.groupby('Mois_Emission').agg({
        'Jours_Retard': 'mean',
        'Est_En_Retard': 'mean',
        ' T.T.C ': 'sum',
        'N° Facture': 'count'
    }).reset_index()

    monthly_stats.columns = ['Mois', 'Retard_moyen', 'Taux_retard', 'CA_total', 'Nb_factures']

    fig, ax1 = plt.subplots(figsize=(12, 6))
    ax1.set_xlabel('Mois')
    ax1.set_ylabel('Retard moyen (jours)', color='tab:red')
    ax1.plot(monthly_stats['Mois'], monthly_stats['Retard_moyen'], color='tab:red', marker='o')
    ax1.tick_params(axis='y', labelcolor='tab:red')

    ax2 = ax1.twinx()
    ax2.set_ylabel('Taux de retard', color='tab:blue')
    ax2.plot(monthly_stats['Mois'], monthly_stats['Taux_retard'], color='tab:blue', marker='x')
    ax2.tick_params(axis='y', labelcolor='tab:blue')

    plt.title('Évolution du retard moyen et du taux de retard par mois')
    plt.xticks(rotation=45)
    fig.tight_layout()
    plt.show()

    fig = make_subplots(specs=[[{"secondary_y": True}]])

    fig.add_trace(go.Scatter(
        x=monthly_stats['Mois'],
        y=monthly_stats['Retard_moyen'],
        name="Retard moyen (jours)",
        marker=dict(color='red')
    ), secondary_y=False)

    fig.add_trace(go.Scatter(
        x=monthly_stats['Mois'],
        y=monthly_stats['Taux_retard'],
        name="Taux de retard",
        marker=dict(color='blue')
    ), secondary_y=True)

    fig.update_layout(
        title_text="Évolution du retard moyen et du taux de retard",
        xaxis_title="Mois"
    )
    fig.update_yaxes(title_text="Retard moyen (jours)", secondary_y=False)
    fig.update_yaxes(title_text="Taux de retard", secondary_y=True)
    fig.show()
plot_delay_trends(df)

"""# 2.4 Retard moyen par client"""

def plot_payment_delay_by_client(df):
    print("\n DÉLAIS DE PAIEMENT PAR CLIENT")

    client_stats = df.groupby(['Code Client', 'Client']).agg({
        'Jours_Retard': 'mean',
        'Est_En_Retard': 'mean',
        ' T.T.C ': 'sum',
        'N° Facture': 'count'
    }).reset_index()

    client_stats.columns = ['Code_Client', 'Client', 'Retard_moyen', 'Taux_retard', 'CA_total', 'Nb_factures']

    significant_clients = client_stats[client_stats['Nb_factures'] >= 5]
    if len(significant_clients) == 0:
        print("Pas assez de donnees pour analyser les clients (>=5 factures)")
        return

    top_delayed = significant_clients.sort_values('Retard_moyen', ascending=False).head(20)

    plt.figure(figsize=(12, 8))
    sns.barplot(data=top_delayed, y='Client', x='Retard_moyen')
    plt.title('Top 20 clients avec le retard moyen le plus élevé (≥5 factures)')
    plt.xlabel('Retard moyen (jours)')
    plt.ylabel('Client')
    plt.tight_layout()
    plt.show()

    plt.figure(figsize=(10, 6))
    sns.scatterplot(
        data=significant_clients,
        x='Retard_moyen',
        y='CA_total',
        size='Nb_factures',
        hue='Taux_retard',
        sizes=(20, 200),
        palette='viridis'
    )
    plt.title('Relation entre retard moyen et CA total par client')
    plt.xlabel('Retard moyen (jours)')
    plt.ylabel('CA total (€)')
    plt.legend(title='Taux de retard')
    plt.show()

    fig = px.scatter(
        significant_clients,
        x='Retard_moyen',
        y='CA_total',
        size='Nb_factures',
        color='Taux_retard',
        hover_name='Client',
        hover_data=['Nb_factures'],
        title='Relation interactive entre retard moyen et CA par client',
        labels={'Retard_moyen': 'Retard moyen (jours)', 'CA_total': 'CA total (€)'}
    )
    fig.update_layout(showlegend=True)
    fig.show()
plot_payment_delay_by_client(df)

"""2.5 Profils clients à risque"""

def identify_risk_profiles(df):
    print("\n IDENTIFICATION DES PROFILS À RISQUE (Dynamique et Détaillé)")

    # Calcul des statistiques par client
    client_profiles = df.groupby(['Code Client', 'Client']).agg(
        Nb_factures_total=('N° Facture', 'count'),
        Nb_factures_retard=('Est_En_Retard', 'sum'),
        Retard_moyen=('Jours_Retard', 'mean'),
        CA_total=(' T.T.C ', 'sum')
    ).reset_index()

    # Calcul du taux de retard et du pourcentage
    client_profiles['Taux_retard'] = client_profiles['Nb_factures_retard'] / client_profiles['Nb_factures_total']
    client_profiles['Pourcentage_retard'] = client_profiles['Taux_retard'] * 100

    # Définition dynamique des seuils de risque (ajustables)
    seuil_haut_risque_pourcentage = 75  # Seuil de pourcentage de factures en retard pour haut risque
    seuil_moyen_risque_pourcentage = 40  # Seuil de pourcentage de factures en retard pour risque modéré
    seuil_min_factures = 5  # Nombre minimum de factures pour être inclus dans l'analyse de risque

    # Filtrage des clients selon les seuils dynamiques
    high_risk = client_profiles[
        (client_profiles['Pourcentage_retard'] >= seuil_haut_risque_pourcentage) &
        (client_profiles['Nb_factures_total'] >= seuil_min_factures)
    ].sort_values('Pourcentage_retard', ascending=False)

    medium_risk = client_profiles[
        (client_profiles['Pourcentage_retard'] >= seuil_moyen_risque_pourcentage) &
        (client_profiles['Pourcentage_retard'] < seuil_haut_risque_pourcentage) &
        (client_profiles['Nb_factures_total'] >= seuil_min_factures)
    ].sort_values('Pourcentage_retard', ascending=False)

    low_risk = client_profiles[
        (client_profiles['Pourcentage_retard'] < seuil_moyen_risque_pourcentage) &
        (client_profiles['Nb_factures_total'] >= seuil_min_factures)
    ].sort_values('Pourcentage_retard', ascending=False)

    # Affichage détaillé des profils
    print(f"\nCLIENTS HAUT RISQUE (>={seuil_haut_risque_pourcentage}% de factures en retard, >={seuil_min_factures} factures):")
    if not high_risk.empty:
        display(high_risk[['Client', 'Pourcentage_retard', 'Retard_moyen', 'CA_total', 'Nb_factures_total']])
    else:
        print("Aucun client correspondant à ce profil")

    print(f"\nCLIENTS RISQUE MODERE ({seuil_moyen_risque_pourcentage}-{seuil_haut_risque_pourcentage}% de factures en retard, >={seuil_min_factures} factures):")
    if not medium_risk.empty:
        display(medium_risk[['Client', 'Pourcentage_retard', 'Retard_moyen', 'CA_total', 'Nb_factures_total']])
    else:
        print("Aucun client correspondant à ce profil")

    print(f"\nCLIENTS FAIBLE RISQUE (<{seuil_moyen_risque_pourcentage}% de factures en retard, >={seuil_min_factures} factures):")
    if not low_risk.empty:
        display(low_risk[['Client', 'Pourcentage_retard', 'Retard_moyen', 'CA_total', 'Nb_factures_total']])
    else:
        print("Aucun client correspondant à ce profil")


    # Visualisation plus détaillée avec Plotly

    fig = px.scatter(
        client_profiles[client_profiles['Nb_factures_total'] >= seuil_min_factures],
        x='Pourcentage_retard',
        y='Retard_moyen',
        size='CA_total',
        color='Nb_factures_total',
        hover_name='Client',
        hover_data=['Code Client', 'Nb_factures_total', 'Nb_factures_retard', 'Taux_retard', 'CA_total'],
        title='Cartographie des profils clients par risque de retard (>= {} factures)'.format(seuil_min_factures),
        labels={'Pourcentage_retard': 'Pourcentage de factures en retard', 'Retard_moyen': 'Retard moyen (jours)'},
        color_continuous_scale=px.colors.sequential.Viridis
    )

    # Ajout des lignes de seuil dynamiques (ASCII only)
    fig.add_vline(x=seuil_moyen_risque_pourcentage, line_dash="dash", line_color="orange", annotation_text="Seuil Risque Modere ({}%)".format(seuil_moyen_risque_pourcentage), annotation_position="top right")
    fig.add_vline(x=seuil_haut_risque_pourcentage, line_dash="dash", line_color="red", annotation_text="Seuil Haut Risque ({}%)".format(seuil_haut_risque_pourcentage), annotation_position="top left")

    fig.update_layout(showlegend=True)
    fig.show()

identify_risk_profiles(df)

df = pd.read_excel("BD_avec_regles_paiement_latest.xlsx", sheet_name=0)  # Adjust sheet_name if needed

# Simple EDA summary with pandas
df_summary = df.describe()
print(df_summary)

import plotly.graph_objects as go
import ipywidgets as widgets
from IPython.display import display

def plot_risk_profile_with_search(df):
    # Assurez-vous que client_profiles est déjà calculé comme dans identify_risk_profiles
    client_profiles = df.groupby(['Code Client', 'Client']).agg(
        Nb_factures_total=('N° Facture', 'count'),
        Nb_factures_retard=('Est_En_Retard', 'sum'),
        Retard_moyen=('Jours_Retard', 'mean'),
        CA_total=(' T.T.C ', 'sum')
    ).reset_index()

    client_profiles['Taux_retard'] = client_profiles['Nb_factures_retard'] / client_profiles['Nb_factures_total']
    client_profiles['Pourcentage_retard'] = client_profiles['Taux_retard'] * 100

    seuil_min_factures = 5
    filtered_profiles = client_profiles[client_profiles['Nb_factures_total'] >= seuil_min_factures].copy()

    # Créer le graphique initial avec tous les points
    fig = go.FigureWidget()

    fig.add_trace(go.Scattergl( # Use Scattergl for potentially large datasets
        x=filtered_profiles['Pourcentage_retard'],
        y=filtered_profiles['Retard_moyen'],
        mode='markers',
        marker=dict(
            size=filtered_profiles['CA_total'] / filtered_profiles['CA_total'].max() * 50, # Taille proportionnelle au CA
            color=filtered_profiles['Nb_factures_total'],
            colorscale='Viridis',
            showscale=True,
            colorbar=dict(title='Nombre de factures')
        ),
        text=filtered_profiles['Client'],
        customdata=filtered_profiles[['Code Client', 'Nb_factures_total', 'Nb_factures_retard', 'Taux_retard', 'CA_total']].values,
        hovertemplate='<b>Client:</b> %{text}<br>' +
                      '<b>Code Client:</b> %{customdata[0]}<br>' +
                      '<b>% Retard:</b> %{x:.2f}%<br>' +
                      '<b>Retard Moyen:</b> %{y:.2f} jours<br>' +
                      '<b>CA Total:</b> %{customdata[4]:,.2f} €<br>' +
                      '<b>Nb Factures:</b> %{customdata[1]}<br>' +
                      '<extra></extra>',
        name='Tous les clients' # Add a name for the trace
    ))

    # Add a second trace for the selected client (initially empty)
    fig.add_trace(go.Scattergl(
        x=[None], # Initially empty
        y=[None], # Initially empty
        mode='markers',
        marker=dict(
            size=100, # Larger size for highlight
            color='red', # Red color for highlight
            line=dict(width=2, color='DarkRed') # Add a border
        ),
        text=[None],
        customdata=[None],
        hovertemplate='<b>Client:</b> %{text}<br>' +
                      '<b>Code Client:</b> %{customdata[0]}<br>' +
                      '<b>% Retard:</b> %{x:.2f}%<br>' +
                      '<b>Retard Moyen:</b> %{y:.2f} jours<br>' +
                      '<b>CA Total:</b> %{customdata[4]:,.2f} €<br>' +
                      '<b>Nb Factures:</b> %{customdata[1]}<br>' +
                      '<extra></extra>',
        name='Client sélectionné' # Add a name for the trace
    ))


    fig.layout.title = f'Cartographie interactive des profils clients (≥{seuil_min_factures} factures)'
    fig.layout.xaxis.title = 'Pourcentage de factures en retard'
    fig.layout.yaxis.title = 'Retard moyen (jours)'

    # Ajouter les lignes de seuil dynamiques (si nécessaire)
    # fig.add_vline(x=seuil_moyen_risque_pourcentage, line_dash="dash", line_color="orange", annotation_text=f"Seuil Risque Modéré ({seuil_moyen_risque_pourcentage}%)", annotation_position="top right")
    # fig.add_vline(x=seuil_haut_risque_pourcentage, line_dash="dash", line_color="red", annotation_text=f"Seuil Haut Risque ({seuil_haut_risque_pourcentage}%)", annotation_position="top left")


    # Créer le widget de sélection
    client_dropdown = widgets.Dropdown(
        options=[('All', 'All')] + [(client, client) for client in filtered_profiles['Client'].unique()],
        value='All',
        description='Sélectionner un client:'
    )

    # Fonction de mise à jour du graphique
    def update_plot(change):
        selected_client = change['new']
        with fig.batch_update():
            if selected_client == 'All':
                # Show all points and hide the selected client trace
                fig.data[0].x = filtered_profiles['Pourcentage_retard']
                fig.data[0].y = filtered_profiles['Retard_moyen']
                fig.data[0].text = filtered_profiles['Client']
                fig.data[0].customdata = filtered_profiles[['Code Client', 'Nb_factures_total', 'Nb_factures_retard', 'Taux_retard', 'CA_total']].values
                fig.data[0].visible = True # Make the 'All clients' trace visible

                fig.data[1].x = [None] # Hide the selected client trace
                fig.data[1].y = [None] # Hide the selected client trace
                fig.data[1].text = [None]
                fig.data[1].customdata = [None]
                fig.data[1].visible = False # Make the 'Selected client' trace invisible

            else:
                # Find the selected client's data
                client_data = filtered_profiles[filtered_profiles['Client'] == selected_client]

                # Hide the 'All clients' trace and show the selected client trace
                fig.data[0].visible = False

                fig.data[1].x = client_data['Pourcentage_retard']
                fig.data[1].y = client_data['Retard_moyen']
                fig.data[1].text = client_data['Client']
                fig.data[1].customdata = client_data[['Code Client', 'Nb_factures_total', 'Nb_factures_retard', 'Taux_retard', 'CA_total']].values
                fig.data[1].visible = True


    # Lier le widget à la fonction de mise à jour
    client_dropdown.observe(update_plot, names='value')

    # Afficher le widget et le graphique
    # display(client_dropdown)  # Optionally comment out if not using Jupyter
    fig.show()

plot_risk_profile_with_search(df)

